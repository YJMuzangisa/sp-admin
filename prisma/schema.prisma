generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                  String               @id @default(cuid())
  name                String?
  email               String               @unique
  password            String
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  emailVerified       DateTime?
  verificationToken   String?              @unique
  isAdmin             Boolean              @default(false)
  ownedBusinesses     Business[]           @relation("BusinessOwner")
  passwordResetTokens PasswordResetToken[]
  managedBusinesses   Business[]           @relation("BusinessManager")
}

model Business {
  id                 String            @id @default(cuid())
  name               String
  takealotApi        String?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  ownerId            String
  paystackCustomerId String?           @unique
  paystackEmail      String?
  pauseMonitoring    Boolean           @default(false)
  ActivityLog        ActivityLog[]
  owner              User              @relation("BusinessOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  Feedback           Feedback[]
  monitoredOffers    LocalOffer[]
  payments           Payment[]
  priceAdjustments   PriceAdjustment[]
  subscription       Subscription?
  offerDTOs          OfferDTO[]
  managers           User[]            @relation("BusinessManager")

  @@index([ownerId])
  @@index([createdAt])
  @@index([updatedAt])
}

model LaunchSignup {
  id        String   @id @default(cuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Subscription {
  id                       String             @id @default(cuid())
  businessId               String             @unique
  planId                   String
  startDate                DateTime
  endDate                  DateTime?
  cancelledAt              DateTime?
  createdAt                DateTime           @default(now())
  updatedAt                DateTime           @updatedAt
  paystackCustomerCode     String
  paystackSubscriptionCode String             @unique
  lastPaymentDate          DateTime?
  nextBillingDate          DateTime?
  status                   SubscriptionStatus @default(TRIAL)
  trialEndsAt              DateTime?
  payStackEmailToken       String?            @unique
  business                 Business           @relation(fields: [businessId], references: [id], onDelete: Cascade)
  plan                     Plan               @relation(fields: [planId], references: [id])

  @@index([businessId, status])
  @@index([status, startDate, endDate])
  @@index([businessId], map: "idx_subscription_business_id")
  @@index([status, nextBillingDate, trialEndsAt], map: "idx_subscription_status_dates")
  @@index([status, nextBillingDate], map: "idx_subscription_status_nextbilling")
  @@index([status, trialEndsAt], map: "idx_subscription_status_trialends")
}

model Payment {
  id          String        @id @default(cuid())
  businessId  String
  amount      Float
  currency    String
  status      PaymentStatus
  paymentDate DateTime
  payStackRef String        @unique
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  business    Business      @relation(fields: [businessId], references: [id], onDelete: Cascade)
}

model OfferDTO {
  id                   String            @id @default(cuid())
  tsinId               BigInt            @map("tsin_id")
  imageUrl             String            @map("image_url")
  offerUrl             String            @map("offer_url")
  sku                  String
  barcode              String
  productLabelNumber   String            @map("product_label_number")
  sellingPrice         Float             @map("selling_price")
  rrp                  Float
  leadtimeDays         Int               @map("leadtime_days")
  leadtimeStock        Json              @map("leadtime_stock")
  status               String
  title                String
  stockAtTakealot      Json              @map("stock_at_takealot")
  stockOnWay           Json              @map("stock_on_way")
  totalStockOnWay      Int               @map("total_stock_on_way")
  stockCover           Json              @map("stock_cover")
  totalStockCover      Int               @map("total_stock_cover")
  salesUnits           Json              @map("sales_units")
  stockAtTakealotTotal Int               @map("stock_at_takealot_total")
  dateCreated          DateTime          @map("date_created")
  storageFeeEligible   Boolean           @map("storage_fee_eligible")
  discount             String?
  discountShown        Boolean           @map("discount_shown")
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  offerId              BigInt            @map("offer_id")
  businessId           String
  inBuyBox             Boolean           @default(false)
  notFoundSince        DateTime?         @db.Timestamp(6)
  notFoundWarned       Boolean?          @default(false)
  atMinPriceSince      DateTime?         @db.Timestamp(6)
  competitorCount      Int?              @default(0)
  localOffer           LocalOffer?       @relation("OfferDTOLocalOffer")
  PriceAdjustment      PriceAdjustment[]
  business             Business          @relation(fields: [businessId], references: [id], onDelete: Cascade)

  @@unique([offerId, businessId])
  @@index([businessId])
  @@index([offerId])
  @@index([offerId, businessId], map: "idx_offers_offerid_business")
  @@index([updatedAt], map: "idx_offers_updatedat")
  @@index([businessId, inBuyBox])
  @@index([businessId, status, inBuyBox])
  @@index([sellingPrice])
  @@index([status, businessId])
  @@map("offers")
}

model LocalOffer {
  id                   String    @id @default(cuid())
  isMonitored          Boolean   @default(true)
  minPrice             Float?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  offerDtoId           BigInt
  businessId           String
  lastMonitored        DateTime?
  nextMonitoring       DateTime?
  receiveNotifications Boolean   @default(false)
  minPriceAlertSent    Boolean   @default(false)
  maxPrice             Float?
  disabledReason       String?
  disabledAt           DateTime? @db.Timestamp(6)
  Business             Business  @relation(fields: [businessId], references: [id], onDelete: Cascade)
  offerDto             OfferDTO  @relation("OfferDTOLocalOffer", fields: [offerDtoId, businessId], references: [offerId, businessId], onDelete: Cascade)

  @@unique([offerDtoId, businessId])
  @@index([businessId])
  @@index([offerDtoId])
  @@index([businessId, isMonitored, lastMonitored])
  @@index([isMonitored, businessId, lastMonitored])
  @@index([isMonitored, nextMonitoring])
  @@index([nextMonitoring])
  @@index([isMonitored, minPrice], map: "idx_localoffer_monitored_minprice")
  @@index([offerDtoId, businessId], map: "idx_localoffer_offer_business")
  @@index([offerDtoId, businessId], map: "idx_localoffer_offerid_business")
}

model Plan {
  id                  String         @id @default(cuid())
  name                String         @unique
  maxOffers           Int
  price               Float
  freeTrialDays       Int            @default(14)
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  maxManagers         Int
  monitoringFrequency Int
  payStackPlanId      String?        @unique
  visible             Boolean        @default(true)
  subscriptions       Subscription[]
}

model Job {
  id         String    @id @unique(map: "idx_job_id") @default(cuid())
  businessId String
  createdAt  DateTime  @default(now())
  type       JobType
  retries    Int       @default(0)
  status     JobStatus @default(PENDING)
  updatedAt  DateTime  @updatedAt
  lockedAt   DateTime?

  @@index([status, lockedAt])
  @@index([businessId, status, createdAt])
  @@index([businessId, status, updatedAt])
  @@index([businessId, type, status])
  @@index([status, createdAt])
  @@index([status, updatedAt])
  @@index([businessId, status, type], map: "idx_job_business_status_type")
  @@index([lockedAt], map: "idx_job_locked")
  @@index([status, type], map: "idx_job_status_type")
  @@index([status, type, createdAt(sort: Desc)], map: "idx_job_status_type_createdat")
  @@index([status, type, lockedAt], map: "idx_job_status_type_lockedat")
}

model Feedback {
  id         String   @id @default(cuid())
  businessId String
  category   String
  message    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  business   Business @relation(fields: [businessId], references: [id], onDelete: Cascade)

  @@index([businessId])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model PriceAdjustment {
  id           Int      @id @default(autoincrement())
  offerId      BigInt
  businessId   String
  price        Float
  createdAt    DateTime @default(now())
  success      Boolean  @default(true)
  errorMessage String?
  business     Business @relation(fields: [businessId], references: [id])
  offer        OfferDTO @relation(fields: [offerId, businessId], references: [offerId, businessId])

  @@index([businessId])
  @@index([offerId, businessId])
  @@index([createdAt])
  @@index([businessId, createdAt])
  @@index([businessId, success, createdAt])
  @@index([success, createdAt])
}

model ActivityLog {
  id         String   @id
  businessId String
  offerId    BigInt?
  offerTitle String?
  type       String
  details    Json?
  createdAt  DateTime @default(now())
  Business   Business @relation(fields: [businessId], references: [id], onDelete: Cascade)

  @@index([businessId, createdAt])
}

model Announcement {
  id        String    @id
  title     String
  content   String
  type      String    @default("feature")
  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  expiresAt DateTime?

  @@index([isActive, createdAt])
}

model BuyboxCheck {
  id              String    @id
  offerId         BigInt
  businessId      String
  checkedAt       DateTime? @default(now()) @db.Timestamp(6)
  hasBuybox       Boolean
  currentPrice    Decimal?  @db.Decimal(10, 2)
  buyboxPrice     Decimal?  @db.Decimal(10, 2)
  competitorCount Int?      @default(0)

  @@index([businessId, checkedAt], map: "idx_buybox_check_business_time")
  @@index([checkedAt], map: "idx_buybox_check_cleanup")
  @@index([offerId, businessId], map: "idx_buybox_check_offer")
}

model BuyboxDailySummary {
  id          String    @id
  offerId     BigInt
  businessId  String
  date        DateTime  @db.Date
  totalChecks Int?      @default(0)
  buyboxWins  Int?      @default(0)
  createdAt   DateTime? @default(now()) @db.Timestamp(6)
  updatedAt   DateTime? @default(now()) @db.Timestamp(6)

  @@unique([offerId, businessId, date])
  @@index([businessId, date], map: "idx_buybox_summary_business_date")
  @@index([offerId, businessId], map: "idx_buybox_summary_offer")
}

model LeadtimeJob {
  id            String   @id
  businessId    String
  offerIds      String
  leadtimeDays  Int
  totalOffers   Int      @default(0)
  status        String   @default("PENDING")
  successCount  Int      @default(0)
  failedCount   Int      @default(0)
  failedMessage String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime

  @@index([status])
}

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  CANCELLED
  PAST_DUE
  EXPIRED
  PENDING
}

enum PaymentStatus {
  PENDING
  SUCCESSFUL
  FAILED
}

enum JobType {
  buyBox
  sync
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
